import { pgTable, text, timestamp, unique, boolean, foreignKey, integer, numeric, jsonb } from "drizzle-orm/pg-core"
import { pgComments, runPgComments } from "./comment.plugin.ts";
import { fileURLToPath } from "url";

// =========================== Better Auth Tables, DO NOT EDIT ===========================
export const verification = pgTable("verification", {
	id: text().primaryKey().notNull(),
	identifier: text().notNull(),
	value: text().notNull(),
	expiresAt: timestamp("expires_at", { mode: 'string' }).notNull(),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { mode: 'string' }).defaultNow().notNull(),
});

export const user = pgTable("user", {
	id: text().primaryKey().notNull(),
	name: text().notNull(),
	email: text().notNull(),
	emailVerified: boolean("email_verified").default(false).notNull(),
	image: text(),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	unique("user_email_unique").on(table.email),
]);

export const account = pgTable("account", {
	id: text().primaryKey().notNull(),
	accountId: text("account_id").notNull(),
	providerId: text("provider_id").notNull(),
	userId: text("user_id").notNull(),
	accessToken: text("access_token"),
	refreshToken: text("refresh_token"),
	idToken: text("id_token"),
	accessTokenExpiresAt: timestamp("access_token_expires_at", { mode: 'string' }),
	refreshTokenExpiresAt: timestamp("refresh_token_expires_at", { mode: 'string' }),
	scope: text(),
	password: text(),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { mode: 'string' }).notNull(),
}, (table) => [
	foreignKey({
		columns: [table.userId],
		foreignColumns: [user.id],
		name: "account_user_id_user_id_fk"
	}).onDelete("cascade"),
]);

export const session = pgTable("session", {
	id: text().primaryKey().notNull(),
	expiresAt: timestamp("expires_at", { mode: 'string' }).notNull(),
	token: text().notNull(),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { mode: 'string' }).notNull(),
	ipAddress: text("ip_address"),
	userAgent: text("user_agent"),
	userId: text("user_id").notNull(),
}, (table) => [
	foreignKey({
		columns: [table.userId],
		foreignColumns: [user.id],
		name: "session_user_id_user_id_fk"
	}).onDelete("cascade"),
	unique("session_token_unique").on(table.token),
]);
// =========================== End of Better Auth Tables, DO NOT EDIT ===========================

/**
 * A source is a specific instance of an IMAP data source from which we ingest emails and process invoices.
 * The creation of a source is triggered by user import action as the web UI flow, and is finished either at the end
 * of OAuth authorization flow (e.g., gmail), or any other means by which a source can be established.
 */
export const source = pgTable("source", {
	// Auto-incrementing integer primary key
	id: integer().primaryKey().generatedAlwaysAsIdentity().notNull(),
	// The name of the source. We use <username>/<provider_type>/<email_address> as the name for convention
	name: text().notNull(),
	// The date and time the source was created
	createdAt: timestamp("created_at", { mode: 'date', withTimezone: true }).defaultNow().notNull(),
	// The date and time the source was last updated
	updatedAt: timestamp("updated_at", { mode: 'date', withTimezone: true }).defaultNow().notNull(),
	// The user ID of the user who owns the source
	userId: text("user_id").notNull(),
	// Email address of the source
	emailAddress: text("email_address").notNull(),
	// Source type, e.g., gmail, outlook, etc. Source type defines the authentication mechanism,
	// IMAP endpoints used for email ingestion, etc.
	sourceType: text("source_type").notNull(),
	// OAuth2 access token, null if the source is not using OAuth2
	oauth2AccessToken: text("oauth2_access_token"),
	// OAuth2 refresh token, null if the source is not using OAuth2
	oauth2RefreshToken: text("oauth2_refresh_token"),
	// OAuth2 access token expiration date, null if the source is not using OAuth2
	oauth2AccessTokenExpiresAt: timestamp("oauth2_access_token_expires_at", { mode: 'string' }),
	// OAuth2 refresh token expiration date, null if the source is not using OAuth2
	oauth2RefreshTokenExpiresAt: timestamp("oauth2_refresh_token_expires_at", { mode: 'string' }),
}, (table) => [
	foreignKey({
		columns: [table.userId],
		foreignColumns: [user.id],
		name: "source_user_id_user_id_fk"
	}).onDelete("cascade"),
]);

pgComments(source, {
	id: "Auto-incrementing integer primary key",
	name: "The name of the source, autogenerated via convention <username>/<provider_type>/<email_address>",
	createdAt: "The date and time the source was created, automatically set to the current timestamp",
	updatedAt: "The date and time the source was last updated, automatically set to the current timestamp",
	userId: "The user ID of the user who owns the source, foreign key to the user table",
	emailAddress: "The email address of the source",
	sourceType: "The type of the source, e.g., gmail, outlook, etc.",
	oauth2AccessToken: "OAuth2 access token, null if the source is not using OAuth2, stored as a string",
	oauth2RefreshToken: "OAuth2 refresh token, null if the source is not using OAuth2, stored as a string",
	oauth2AccessTokenExpiresAt: "OAuth2 access token expiration date, null if the source is not using OAuth2, stored as a string in ISO 8601 format",
	oauth2RefreshTokenExpiresAt: "OAuth2 refresh token expiration date, null if the source is not using OAuth2, stored as a string in ISO 8601 format",
});

export const sourceFolder = pgTable("source_folder", {
	id: integer().primaryKey().generatedAlwaysAsIdentity().notNull(),
	sourceId: integer("source_id").notNull(),
	folderName: text("folder_name").notNull(),
	uidValidity: text("uid_validity").notNull(),

	// Largest message UID in the folder that has been processed
	highWaterMark: integer("high_water_mark"), // null = haven't processed any messages yet
	// Smallest message UID in the folder that has been processed
	lowWaterMark: integer("low_water_mark"),  // null = haven't processed old messages yet

	lastProcessedAt: timestamp("last_processed_at", { mode: 'date', withTimezone: true }),
	createdAt: timestamp("created_at", { mode: 'date', withTimezone: true }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { mode: 'date', withTimezone: true }).defaultNow().notNull(),
}, (table) => [
	foreignKey({
		columns: [table.sourceId],
		foreignColumns: [source.id],
		name: "source_folder_source_id_source_id_fk"
	}).onDelete("cascade"),
]);

pgComments(sourceFolder, {
	id: "Auto-incrementing integer primary key",
	sourceId: "The source ID of the source that contains the folder, foreign key to the source table",
	folderName: "The name of the folder, stored as a string",
	uidValidity: "The UID validity of the folder, stored as a string",
	highWaterMark: "The largest message UID in the folder that has been processed, stored as an integer, null if haven't processed any messages yet",
	lowWaterMark: "The smallest message UID in the folder that has been processed, stored as an integer, null if haven't processed old messages yet",
	lastProcessedAt: "The date and time the folder was last processed, stored as a date in ISO 8601 format",
	createdAt: "The date and time the folder was created, stored as a date in ISO 8601 format",
	updatedAt: "The date and time the folder was last updated, stored as a date in ISO 8601 format",
});

/**
 * A line item is a single item in an invoice.
 */
export type LineItem = {
	description: string;
	quantity?: number;
	unitPrice?: number;
}

export type AttachedFile = {
	// The name of the file
	fileName: string;
	// The S3 object key of the file
	fileKey: string;
}

/**
 * An invoice is a single invoice found in a source.
 */
export const invoice = pgTable("invoice", {
	// Auto-incrementing integer primary key
	id: integer().primaryKey().generatedAlwaysAsIdentity().notNull(),
	// The source ID of the source that contains the invoice
	sourceId: integer("source_id"),
	// IMAP UID of the email that contains the invoice.
	uid: integer("uid"),
	// IMAP message ID of the email that contains the invoice
	messageId: text("message_id"),
	// The invoice or receipt number
	invoiceNumber: text("invoice_number"),
	// Vendor name
	vendorName: text("vendor_name"),
	// Due date
	dueDate: timestamp("due_date", { mode: 'date', withTimezone: true }),
	// Total amount
	totalAmount: numeric("total_amount", { precision: 10, scale: 2 }),
	// Currency
	currency: text("currency"),
	// Payment status
	paymentStatus: text("payment_status"),
	// Line Items included in the invoice
	lineItems: jsonb("line_items").$type<LineItem[]>(),
	// Attached files in the invoice
	attachedFiles: jsonb("attached_files").$type<AttachedFile[]>(),
	// The date and time the invoice was created
	createdAt: timestamp("created_at", { mode: 'date', withTimezone: true }).defaultNow().notNull(),
	// The date and time the invoice was last updated
	updatedAt: timestamp("updated_at", { mode: 'date', withTimezone: true }).defaultNow().notNull(),
	// The user ID of the user who owns the invoice
	userId: text("user_id").notNull(),
}, (table) => [
	foreignKey({
		columns: [table.userId],
		foreignColumns: [user.id],
		name: "invoice_user_id_user_id_fk"
	}).onDelete("cascade"),
	foreignKey({
		columns: [table.sourceId],
		foreignColumns: [source.id],
		name: "invoice_source_id_source_id_fk"
	}).onDelete("set null"), // When deleted, we don't want to delete all the invoices.
]);

pgComments(invoice, {
	id: "Auto-incrementing integer primary key",
	sourceId: "The source ID of the source that contains the invoice, foreign key to the source table",
	uid: "The IMAP UID of the email that contains the invoice, stored as an integer",
	messageId: "The IMAP message ID of the email that contains the invoice, stored as a string",
	invoiceNumber: "The invoice or receipt number, stored as a string",
	vendorName: "The vendor name, stored as a string",
	dueDate: "The due date, stored as a date in ISO 8601 format",
	totalAmount: "The total amount, stored as a numeric value",
	currency: "The currency, stored as a string",
	paymentStatus: "The payment status, stored as a string, e.g., paid, unpaid, pending, etc.",
	lineItems: "The line items, stored as a JSON array of LineItem objects, each containing a description, quantity, and unit price",
	attachedFiles: "The attached files in the invoice, stored as a JSON array of AttachedFile objects, each containing a file name and S3 object key",
	createdAt: "The date and time the invoice was created, automatically set to the current timestamp",
	updatedAt: "The date and time the invoice was last updated, automatically set to the current timestamp",
	userId: "The user ID of the user who owns the invoice, foreign key to the user table",
});

function isEntryPoint(importMetaUrl: string) {
	const __filename = fileURLToPath(importMetaUrl)
	const __entryFile = process.argv?.[1]
	return __entryFile === __filename
}

if (isEntryPoint(import.meta.url)) {
	runPgComments()
}